using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;

namespace ConsoleApplication1
{
    /// <remarks>Class <c>Program</c> Сортируем массивы различными методами.
    /// </remarks>
    class Program
    {
        private const int _size = 100;//размер массива
        private const int _min = -100;//минимальное значение чисел в массиве
        private const int _max = 100;//максимальное значение чисел в массиве

        /// <summary>
        /// Создать массив из 100 чисел и заполнить его случайными числами от -100 до 100.
        /// Реализовать 2 вида сортировки , вычислить время работы алгоритма и подсчитать количество перестановок. 
        /// Для того, чтобы узнать время работы алгоритма изучите работу с классом Stopwatch.
        /// </summary>
        /// <param name='args'>
        /// Действия с параметром отсутствуют.
        /// </param>
        static void Main(string[] args)
        {
            int[] arr0 = new int[_size];//Итиализация массива, в котором будут случайные числа
            int[] arr1 = new int[_size];//Итиализация массива, который будет отсортерован по методу 'SortA'
            int[] arr2 = new int[_size];//Итиализация массива, который будет отсортерован по методу 'SortB'

            Array.Copy(GenerateArr(_min, _max, _size), arr0, _size);//Создаём массив случайных чисел и присваеваем его к "arr0"
            Array.Copy(arr0, arr1, _size);//Копируем массив "arr0" в "arr1"
            Array.Copy(arr0, arr2, _size);//Копируем массив "arr0" в "arr2"
            
            Stopwatch stopwatch1 = new Stopwatch();//Создаём первый секундомер
            stopwatch1.Start();//Запускаем первый секундомер
            SortA(arr1);//Сортируем "arr1" методом "SortA"
            stopwatch1.Stop();//Останавливаем первый секундомер

            Stopwatch stopwatch2 = new Stopwatch();//Создаём второй секундомер
            stopwatch2.Start();//Запускаем второй секундомер
            SortB(arr2, 0, _size-1);//Сортируем "arr2" методом "SortB"
            stopwatch2.Stop();//Останавливаем первый секундомер

            //Пичатаем все данные
            //Первый столбец - не отсортерованные значения
            //второй столбец - отсортерованные значения по методу "SortA"
            //третий столбец - отсортерованные значения по методу "SortB"
            Console.WriteLine("Orig \t SortA \t SortB");
            for (int i = 0; i < _size; i++)
            {
                Console.WriteLine(arr0[i]+" \t"+arr1[i]+" \t"+arr2[i]);
            }
            Console.WriteLine("Orig \t SortA \t SortB");
            Console.WriteLine("");
            Console.WriteLine("Metod SortA zanjal vremjani: " + stopwatch1.Elapsed);
            Console.WriteLine("Metod SortB zanjal vremjani: " + stopwatch2.Elapsed);

            Console.ReadLine();//Пауза, что бы посмотреть результаты на экране
        }


        /// <summary>
        /// Создать массив из 100 чисел и заполнить его случайными числами от -100 до 100.
        /// </summary>
        /// <param name="min">
        /// Минимальное значение элемента
        /// </param>
        /// <param name="max">
        /// Максимальное значение элемента
        /// </param>
        /// /// <param name="size">
        /// Размер массива
        /// </param>
        /// <returns>
        /// Массив <c>int[]</c>
        /// </returns>
        private static int[] GenerateArr(int min, int max, int size)
        {
            Random rnd = new Random();//создаём новые генератор случайных чисел
            int[] arr = new int[size];//итиализируем массив размером "size"

            for (int i = 0; i < arr.Length; i++ )//цикл от 0 до длины массива
            {
                arr[i] = rnd.Next(min, max);//Генирируем случайное число от "min" до "max" и присваеваем его элементу "i" в массиве "arr"
            }
            return arr;//Возврат готового массива
        }

        /// <summary>
        /// Сортировка 1. Простое преремещение данных.
        /// </summary>
        /// <param name='arr'>
        /// Массив чисел для сортировки
        /// </param>
        private static void SortA(int[] arr)
        {
            int temp;//временная переменна для обмена
            int count = 1;//счётчик. начинаем с 1, т.к. будем сравнивать текущий элемент с предыдущим
            while (count < arr.Length)//цикл от 1 до последнего элемента.
            {
                if (arr[count] < arr[count - 1])//если предыдущий элемент больше текущего
                {
                    //то меняем их местами. Далее логика обена.
                    temp = arr[count - 1];
                    arr[count - 1] = arr[count];
                    arr[count] = temp;

                    if(count<=1)//если это крайний элемент, то преходим к следующему
                    {
                        count++;
                    }else//в другом случае, возвращаемся на шаг назад, что бы проверить отношение "предпредыдущего" с обновлённым "предыдущим"
                    {
                        count--; 
                    }
                }else//в другом случае переходим к следующему элементу
                {
                    count++;
                }
            }
        }

        /// <summary>
        /// Сортировка 2. Так называеммая "Быстрая сортировка".
        ///     1) выбрать элемент, называемый опорным.
        ///     2) сравнить все остальные элементы с опорным, на основании сравнения разбить множество на два
        ///          — «меньшие опорного» и «большие», расположить их в порядке меньшие-большие.
        ///     3) повторить рекурсивно для «меньших» и «больших».
        /// </summary>
        /// <param name='arr'>
        /// Массив чисел для сортировки
        /// </param>
        /// <param name="min">
        /// Индекс первого элемента в массиве. Откуда сортируем.
        /// </param>
        /// <param name="max">
        /// Индекс последнего элемента в массиве. До куда сортируем.
        /// </param>
        private static void SortB(int[] arr, int min, int max)
        {
            int temp;//временная переменна для обмена
            int i = min;// Индекс первого элемента в массиве. Откуда сортируем.
            int j = max;// Индекс последнего элемента в массиве. До куда сортируем.
            int x = arr[(min+max)/2];// Назначаем опорное значение
            do
            {
                while (arr[i] < x) ++i;//перебор элементов от наименьшего индекса. Сравнивание этого элемента с опорным. Останавливаемся если элемент больше опорного.
                while (arr[j] > x) --j;//перебор элементов от наибольшего индекса. Сравнивание этого элемента с опорным. Останавливаемся если элемент меньше опорного.
                if(i<=j)//обмен элементов, если i меньше, или равно j. Исходя из предыдущик двух строк - это произойдёт только если число с меньшим индексом (i) больше(или равно) числа с большим индексом (j).
                {
                    temp = arr[ i ];
                    arr[ i ] = arr[ j ];
                    arr[ j ] = temp;
                    i++;
                    j--;
                }
                
            }
            while( i <= j );

            if (min < j) SortB( arr, min, j );//повтор сортировки для чисел с меньшими индексами
            if (i < max) SortB( arr, i, max );//повтор сортировки для чисел с большими индексами
        }
    }
}
